input â† â€¢file.Lines "inputTest"

# part 1
input â†© '0' -Ëœ >input

#lr1 â† (9Â»Ë˜input) - input
#lr2 â† (9Â«Ë˜input) - input
#â€¢Show lr â† (lr1 > 0) âˆ§ (lr2 > 0)

# refactored
lr â† ((0âŠ¸<9âŠ¸Â»Ë˜-âŠ¢)âˆ§(0âŠ¸<9âŠ¸Â«Ë˜-âŠ¢)) input

#ud1â† â‰(9Â»Ë˜â‰input) - â‰input
#ud2â† â‰(9Â«Ë˜â‰input) - â‰input
#ud â† (ud1 > 0) âˆ§ (ud2 > 0)

# refactored
ud â† ((0âŠ¸<9âŠ¸Â»Ë˜-âŠ¢)âˆ§(0âŠ¸<9âŠ¸Â«Ë˜-âŠ¢))âŒ¾â‰ input

lowPointsMask â† lr âˆ§ ud

#allLowPoints â† (<Ë˜(lr âˆ§ ud)) /Â¨ <Ë˜input

# refactored
allLowPoints â† âˆ¾lowPointsMask (/Â¨â—‹<Ë˜) input
+Â´1+((0âŠ¸<â‰ )Â¨/âŠ¢) allLowPoints

# part 2
# first iter
borderOf9 â† Â¯1Ã—input = 9
# append top, left walls of '9' borders 
#â€¢Show borderOf9 â†© {Â¯1 âˆ¾Ë˜ ğ•©} âŒ¾â‰ Â¯1 âˆ¾Ë˜ borderOf9
#
#â€¢Show first2rows â† 0â€¿1âŠborderOf9

globalCounter â† Â¯1

â€¢Show a â† â¥ŠË˜âŠ2â€¿2â†• first2rows

â€¢Show firstPassRow â† {
  upâ€¿leftâ€¿selfâ†1â†“ğ•©

  # 3 scenarios:
  # if self â‰¢ Â¯1, then return Â¯1 (below 2 scn, assum self â‰¥ 0)
  # if upâ€¿left â‰¡ Â¯1 then return globalCounter+â†©1 (new area)
  # if up OR left â‰¥ 0 then return the segment â‰¥ 0 (existing area)?? Another pass
  {
    selfâ‰¡Â¯1?Â¯1;
      upâ€¿left â‰¡ Â¯1â€¿Â¯1?globalCounter +â†© 1; 
        globalCounter
  }
}Ë˜ a

#2nd iter
borderOf9 â†© (Â¯1âˆ¾firstPassRow)âŒ¾(1âŠ¸âŠ) borderOf9

â€¢Show next2rows â† 1â€¿2âŠborderOf9

â€¢Show b â† â¥ŠË˜âŠ2â€¿2â†• next2rows

â€¢Show {
  upâ€¿leftâ€¿selfâ†1â†“ğ•©

  # 3 scenarios:
  # if self â‰¢ Â¯1, then return Â¯1 (below 2 scn, assum self â‰¥ 0)
  # if upâ€¿left â‰¡ Â¯1 then return globalCounter+â†©1 (new area)
  # if up OR left â‰¥ 0 then return the segment â‰¥ 0 (existing area)?? Another pass
  {
    selfâ‰¡Â¯1?Â¯1;
      upâ€¿left â‰¡ Â¯1â€¿Â¯1?globalCounter +â†© 1; 
       âŠ‘(upâ€¿leftâ‰¥0)/upâ€¿left  ## problem.. how to get the prevoius LEFT value?
  }
}Ë˜b 
